// Generated by Copilot
import { defineEventHandler, readBody } from 'h3';
import type { CopilotMetrics } from "@/model/Copilot_Metrics";
import { convertToMetrics } from '@/model/MetricsToUsageConverter';
import { ensureCopilotMetrics } from '@/model/Copilot_Metrics';
import type { MetricsApiResponse } from "@/types/metricsApiResponse";
import { getTeams } from './teams';
import { readFileSync } from 'fs';
import { resolve } from 'path';

/**
 * Handler for multiple teams metrics API endpoint
 * This endpoint processes metrics for multiple teams simultaneously
 * 
 * Generated by Copilot
 */
export default defineEventHandler(async (event) => {
    const body = await readBody(event);
    const config = useRuntimeConfig(event);
    const logger = console;
    
    // Extract teams and organization from the request body or fetch them if not provided
    let { teams = [] as { name: string; slug: string }[], organization } = body;
    const orgName = organization || config.public.githubOrg;
    
    // If teams array is empty or not provided, fetch teams from the API
    if (!teams || teams.length === 0) {
        logger.info(`No teams provided in request body, fetching teams for organization: ${orgName}`);
        try {
            teams = await getTeams(event, orgName);
        } catch (error) {
            logger.error(`Failed to fetch teams for organization ${orgName}:`, error);
            return new Response(`Failed to fetch teams for organization ${orgName}`, { status: 500 });
        }
    }
    
    if (!event.context.headers.has('Authorization')) {
        return new Response('No Authentication provided', { status: 401 });
    }

    const allMetrics = [];
    const teamMetrics = [];

    // If mock mode is enabled
    if (config.public.isDataMocked) {
        const mockedDataPath = resolve('public/mock-data/organization_metrics_response_sample.json');
        const data = readFileSync(mockedDataPath, 'utf8');
        const dataJson = JSON.parse(data);
        const usageData = ensureCopilotMetrics(dataJson);
        const metricsData = convertToMetrics(usageData);

        // Replicate mock data for each team
        for (const team of teams) {
            teamMetrics.push({ team: { name: team.name, slug: team.slug }, metrics: metricsData });
            allMetrics.push(...metricsData.map(metric => ({
                ...metric,
                team: team.name,
                teamSlug: team.slug
            })));
        }

        return { metrics: allMetrics, teamMetrics };
    }

    // Handle real API calls
    for (const team of teams) {
        try {
            const teamSlug = team.slug || team.name.toLowerCase().replace(/\s+/g, '-');
            const apiUrl = `https://api.github.com/orgs/${orgName}/teams/${teamSlug}/copilot/metrics`;
            
            logger.info(`Fetching metrics for team ${team.name} (${teamSlug}) from ${apiUrl}`);
            
            const response = await $fetch(apiUrl, {
                headers: event.context.headers
            }) as unknown[];
            
            if (response) {
                // Process the response data 
                const usageData = ensureCopilotMetrics(response);
                const metricsData = convertToMetrics(usageData);
                
                // Add team and metrics to teamMetrics
                teamMetrics.push({ team: { name: team.name, slug: teamSlug }, metrics: metricsData });
                
                // Add team information to each metrics object
                const metricsWithTeam = metricsData.map(metric => ({
                    ...metric,
                    team: team.name, // Add team name for display
                    teamSlug: teamSlug // Add team slug for unique identification
                }));
                
                // Add metrics with team info to allMetrics array
                allMetrics.push(...metricsWithTeam);
            }
        } catch (error) {
            logger.error(`Error fetching metrics for team ${team.name}:`, error);
            // Continue with other teams rather than failing the whole request
        }
    }

    // Sort teams by name for consistent display
    teamMetrics.sort((a, b) => a.team.name.localeCompare(b.team.name));

    logger.info(`Processed ${teamMetrics.length} teams with ${allMetrics.length} total metrics records`);
    
    return { metrics: allMetrics, teamMetrics };
});