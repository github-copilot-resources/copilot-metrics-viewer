// Generated by Copilot
import { defineEventHandler, readBody } from 'h3';
import type { CopilotMetrics } from "@/model/Copilot_Metrics";
import { convertToMetrics } from '@/model/MetricsToUsageConverter';
import type { MetricsApiResponse } from "@/types/metricsApiResponse";
import { readFileSync } from 'fs';
import { resolve } from 'path';

export default defineEventHandler(async (event) => {
    const body = await readBody(event);
    // Extract teams and organization from the request body, ensuring teams is an array of objects with name and slug properties
    const { teams = [] as { name: string; slug: string }[], organization } = body; // Generated by Copilot
    const config = useRuntimeConfig(event);
    
    // Use organization from request body if provided
    const orgName = organization || config.public.githubOrg;
    
    if (!event.context.headers.has('Authorization')) {
        return new Response('No Authentication provided', { status: 401 });
    }

    const allMetrics = [];
    const teamMetrics = [];

    // If mock mode is enabled
    if (config.public.isDataMocked) {
        const mockedDataPath = resolve('public/mock-data/organization_metrics_response_sample.json');
        const data = readFileSync(mockedDataPath, 'utf8');
        const dataJson = JSON.parse(data);
        const usageData = ensureCopilotMetrics(dataJson);
        const metricsData = convertToMetrics(usageData);

        // Replicate mock data for each team
        for (const team of teams) {
            teamMetrics.push({ team: { name: team.name, slug: team.slug }, metrics: metricsData });
            allMetrics.push(...metricsData);
        }

        return { metrics: allMetrics, teamMetrics };
    }

    // Handle real API calls
    for (const team of teams) {
        try {
            const teamSlug = team.slug || team.name.toLowerCase().replace(/\s+/g, '-');
            const apiUrl = `https://api.github.com/orgs/${orgName}/teams/${teamSlug}/copilot/metrics`;
            
            const response = await $fetch(apiUrl, {
                headers: event.context.headers
            }) as unknown[];
            
            if (response) {

                //there is no team info in the response, so we need to add it manually
                // Check if the response is an array and contains valid data
                const usageData = ensureCopilotMetrics(response);
                const metricsData = convertToMetrics(usageData);
                
                // Add team and metrics to teamMetrics
                teamMetrics.push({ team: { name: team.name, slug: teamSlug }, metrics: metricsData });
                
                // Generated by Copilot: Add team information to each metrics object before adding to allMetrics
                // This allows filtering by team information later in the frontend
                const metricsWithTeam = metricsData.map(metric => ({
                    ...metric,
                    team: team.name, // Add team name for display
                    teamSlug: teamSlug // Add team slug for unique identification
                }));
                
                // Add metrics with team info to allMetrics array
                allMetrics.push(...metricsWithTeam);
            
            }
        } catch (error) {
            // Handle errors gracefully
        }
    }

    // Sort teams by name for consistent display
    teamMetrics.sort((a, b) => a.team.name.localeCompare(b.team.name));
    //console.log('Team metrics:', teamMetrics);
    

    console.log(`Number of teams: ${teamMetrics.length}`);
    console.log(`Number of metrics: ${allMetrics.length}`);
    
    return { metrics: allMetrics, teamMetrics };
});

// Helper function to get teams
async function getTeams(event: any, orgName: string): Promise<{ name: string; slug: string }[]> { // Generated by Copilot
    const config = useRuntimeConfig(event);
    const body = await readBody(event);
    const { organization } = body;
    
    orgName = organization || orgName;
    
    try {
        const response = await $fetch(`https://api.github.com/orgs/${orgName}/teams`, {
            headers: event.context.headers
        }) as any[];
        
        if (!Array.isArray(response)) {
            throw new Error('Invalid response format from GitHub API');
        }
        
        if (config.public.githubTeam && config.public.githubTeam.trim() !== '') {
            const teamsFromConfig = config.public.githubTeam.split(',').map(team => team.trim());
            const filteredTeams = response.filter(team =>
                teamsFromConfig.includes(team.name)
            );

            return filteredTeams.map(team => ({
                name: team.name,
                slug: team.slug || team.name.toLowerCase().replace(/\s+/g, '-')
            }));
        }

        return response.map(team => ({
            name: team.name || team.slug,
            slug: team.slug || team.name?.toLowerCase().replace(/\s+/g, '-')
        }));
    } catch (error: any) {
        throw error;
    }
}

// Helper function from metrics.ts
function ensureCopilotMetrics(data: any[]): CopilotMetrics[] {
    return data.map(item => {
        if (!item.copilot_ide_code_completions) {
            item.copilot_ide_code_completions = { editors: [], total_engaged_users: 0, languages: [] };
        }
        item.copilot_ide_code_completions.editors?.forEach((editor: any) => {
            editor.models?.forEach((model: any) => {
                if (!model.languages) {
                    model.languages = [];
                }
            });
        });
        return item as CopilotMetrics;
    });
}