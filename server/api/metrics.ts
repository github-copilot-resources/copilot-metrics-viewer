import type { CopilotMetrics } from "@/model/Copilot_Metrics";
import { convertToMetrics } from '@/model/MetricsToUsageConverter';
import { ensureCopilotMetrics } from '@/model/Copilot_Metrics'; // Import the ensureCopilotMetrics function from model
import type { MetricsApiResponse } from "@/types/metricsApiResponse";
import type FetchError from 'ofetch';
import { getTeamSlugByName } from './teams'; // Import getTeamSlugByName function

// TODO: use for storage https://unstorage.unjs.io/drivers/azure

import { readFileSync } from 'fs';
import { resolve } from 'path';

export default defineEventHandler(async (event) => {

        // Generated by Copilot - Server-side API logging
    const timestamp = new Date().toISOString();
    console.log(`游리 [SERVER] API metrics START - ${timestamp}`);
    console.log(`游리 [SERVER] Event context received:`, {
        scope: event.context.scope,
        ent: event.context.ent,
        org: event.context.org,
        team: event.context.team
    });

    const logger = console;
    const config = useRuntimeConfig(event);

    
    // Generated by Copilot - Detailed config object analysis
    console.log(`游리 [SERVER] Config object details:`, {
        configObjectId: (config as any).$$id || 'no-id',
        isProxy: config.constructor.name === 'Object' ? 'Object' : config.constructor.name,
        publicObjectId: (config.public as any).$$id || 'no-public-id',
        memoryPattern: JSON.stringify(config.public).substring(0, 50),
        eventId: event.context.id || 'no-event-id'
    });

    console.log(`游리 [SERVER] Config values in metrics.ts:`, {
        githubEnt: config.public.githubEnt,
        githubOrg: config.public.githubOrg,
        githubTeam: config.public.githubTeam,
        scope: config.public.scope,
        isDataMocked: config.public.isDataMocked
    });


    // get the enterprise/org/team slug from query parameters or event context
    // and use it to get the metrics
    // Initialize API URL and mocked data path

    // Get query parameters from URL
    const query = getQuery(event);
    const OrgName = (query.org as string) ||  '';
    const TeamName = (query.team as string) || '';
    const EntName = (query.ent as string) || '';

    logger.debug(`游리 OrgName: ${OrgName}, TeamName: ${TeamName}, EntName: ${EntName}`);
    let scope: 'team' | 'org' | 'ent' = 'org'; // Default to org if no parameters are provided
    
    // calculate the scope based on the provided parameters
    if (TeamName && OrgName) {
        scope = 'team';
    } else if (OrgName) {
        scope = 'org';
    } else if (EntName) {
        scope = 'ent';
    }

    let apiUrl = '';
    let mockedDataPath: string;
    

    logger.debug(` 游리 event context before route: org is ${event.context.org}, team=${event.context.team}, ent=${event.context.ent}庸깐vent.context.scope=${event.context.scope}`);
    logger.debug(`游리 Using scope from parameters: scope is ${scope};  Org is: ${OrgName}, Team is: ${TeamName}, Ent is: ${EntName}`);
/*     // Check for query parameters that can override the context
    const query = getQuery(event);
    
    // Override context with query parameters if provided
    if (query.scope) event.context.scope = query.scope as string;
    if (query.team) event.context.team = query.team as string;
    if (query.org) event.context.org = query.org as string;
    if (query.ent) event.context.ent = query.ent as string;

    // Log the values we're using,especially the event.context
    //logger.debug('Event context:', event.context);
    logger.debug(`Event context after consider querying: org=${event.context.org}, team=${event.context.team}, ent=${event.context.ent}庸깐vent.context.scope=${event.context.scope}`);
 */
    switch (scope) {
        case 'team':

            // get team slug by name, then use it to get the metrics
            const teamSlug = await getTeamSlugByName(event, TeamName, OrgName);
            if (!teamSlug) {
                logger.error(`游리 Team slug not found for team: ${TeamName}`);
                return new Response(`游리 Team slug not found for team: ${TeamName}`, { status: 404 });
            }
            apiUrl = `https://api.github.com/orgs/${OrgName}/team/${teamSlug}/copilot/metrics`;
            // no team test data available, using org data
            // '../../app/mock-data/organization_metrics_response_sample.json'
            mockedDataPath = resolve('public/mock-data/organization_metrics_response_sample.json');
            break;
        case 'org':
            apiUrl = `https://api.github.com/orgs/${OrgName}/copilot/metrics`;
            mockedDataPath = resolve('public/mock-data/organization_metrics_response_sample.json');
            break;
        case 'ent':
            apiUrl = `https://api.github.com/enterprises/${EntName}/copilot/metrics`;
            mockedDataPath = resolve('public/mock-data/enterprise_metrics_response_sample.json');
            break;
        default:
            return new Response('Invalid configuration/parameters for the request', { status: 400 });
    }

    if (config.public.isDataMocked && mockedDataPath) {
        const path = mockedDataPath;
        const data = readFileSync(path, 'utf8');
        const dataJson = JSON.parse(data);
        // usage is the new API format
        const usageData = ensureCopilotMetrics(dataJson);
        // metrics is the old API format
        const metricsData = convertToMetrics(usageData);

        logger.info('Using mocked data');
        return { metrics: metricsData, usage: usageData } as MetricsApiResponse;
    }

    if (!event.context.headers.has('Authorization')) {
        logger.error('No Authentication provided');
        return new Response('No Authentication provided', { status: 401 });
    }

    logger.info(`游리 Fetching metrics data from ${apiUrl}`);

    try {
        const response = await $fetch(apiUrl, {
            headers: event.context.headers
        }) as unknown[];

        // usage is the new API format
        // Define a proper type for the response to maintain type safety
        const usageData = ensureCopilotMetrics(response as CopilotMetrics[]);
        // metrics is the old API format
        const metricsData = convertToMetrics(usageData);
        return { metrics: metricsData, usage: usageData } as MetricsApiResponse;
    } catch (error: any) {
        logger.error('游리 Error fetching metrics data:', error);
        return new Response('游리 Error fetching metrics data: ' + error, { status: error.statusCode || 500 });
    }
})